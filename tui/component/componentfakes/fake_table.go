// Code generated by counterfeiter. DO NOT EDIT.
package componentfakes

import (
	"sync"

	"github.com/dkyanakiev/vaulty/tui/component"
	tcell "github.com/gdamore/tcell/v2"
	"github.com/rivo/tview"
)

type FakeTable struct {
	ClearStub        func()
	clearMutex       sync.RWMutex
	clearArgsForCall []struct {
	}
	GetCellContentStub        func(int, int) string
	getCellContentMutex       sync.RWMutex
	getCellContentArgsForCall []struct {
		arg1 int
		arg2 int
	}
	getCellContentReturns struct {
		result1 string
	}
	getCellContentReturnsOnCall map[int]struct {
		result1 string
	}
	GetSelectionStub        func() (int, int)
	getSelectionMutex       sync.RWMutex
	getSelectionArgsForCall []struct {
	}
	getSelectionReturns struct {
		result1 int
		result2 int
	}
	getSelectionReturnsOnCall map[int]struct {
		result1 int
		result2 int
	}
	PrimitiveStub        func() tview.Primitive
	primitiveMutex       sync.RWMutex
	primitiveArgsForCall []struct {
	}
	primitiveReturns struct {
		result1 tview.Primitive
	}
	primitiveReturnsOnCall map[int]struct {
		result1 tview.Primitive
	}
	RenderHeaderStub        func([]string)
	renderHeaderMutex       sync.RWMutex
	renderHeaderArgsForCall []struct {
		arg1 []string
	}
	RenderRowStub        func([]string, int, tcell.Color)
	renderRowMutex       sync.RWMutex
	renderRowArgsForCall []struct {
		arg1 []string
		arg2 int
		arg3 tcell.Color
	}
	ScrollToTopStub        func() *tview.Table
	scrollToTopMutex       sync.RWMutex
	scrollToTopArgsForCall []struct {
	}
	scrollToTopReturns struct {
		result1 *tview.Table
	}
	scrollToTopReturnsOnCall map[int]struct {
		result1 *tview.Table
	}
	SetInputCaptureStub        func(func(event *tcell.EventKey) *tcell.EventKey)
	setInputCaptureMutex       sync.RWMutex
	setInputCaptureArgsForCall []struct {
		arg1 func(event *tcell.EventKey) *tcell.EventKey
	}
	SetSelectedFuncStub        func(func(row int, column int))
	setSelectedFuncMutex       sync.RWMutex
	setSelectedFuncArgsForCall []struct {
		arg1 func(row int, column int)
	}
	SetTitleStub        func(string, ...interface{})
	setTitleMutex       sync.RWMutex
	setTitleArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTable) Clear() {
	fake.clearMutex.Lock()
	fake.clearArgsForCall = append(fake.clearArgsForCall, struct {
	}{})
	stub := fake.ClearStub
	fake.recordInvocation("Clear", []interface{}{})
	fake.clearMutex.Unlock()
	if stub != nil {
		fake.ClearStub()
	}
}

func (fake *FakeTable) ClearCallCount() int {
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	return len(fake.clearArgsForCall)
}

func (fake *FakeTable) ClearCalls(stub func()) {
	fake.clearMutex.Lock()
	defer fake.clearMutex.Unlock()
	fake.ClearStub = stub
}

func (fake *FakeTable) GetCellContent(arg1 int, arg2 int) string {
	fake.getCellContentMutex.Lock()
	ret, specificReturn := fake.getCellContentReturnsOnCall[len(fake.getCellContentArgsForCall)]
	fake.getCellContentArgsForCall = append(fake.getCellContentArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.GetCellContentStub
	fakeReturns := fake.getCellContentReturns
	fake.recordInvocation("GetCellContent", []interface{}{arg1, arg2})
	fake.getCellContentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTable) GetCellContentCallCount() int {
	fake.getCellContentMutex.RLock()
	defer fake.getCellContentMutex.RUnlock()
	return len(fake.getCellContentArgsForCall)
}

func (fake *FakeTable) GetCellContentCalls(stub func(int, int) string) {
	fake.getCellContentMutex.Lock()
	defer fake.getCellContentMutex.Unlock()
	fake.GetCellContentStub = stub
}

func (fake *FakeTable) GetCellContentArgsForCall(i int) (int, int) {
	fake.getCellContentMutex.RLock()
	defer fake.getCellContentMutex.RUnlock()
	argsForCall := fake.getCellContentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTable) GetCellContentReturns(result1 string) {
	fake.getCellContentMutex.Lock()
	defer fake.getCellContentMutex.Unlock()
	fake.GetCellContentStub = nil
	fake.getCellContentReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTable) GetCellContentReturnsOnCall(i int, result1 string) {
	fake.getCellContentMutex.Lock()
	defer fake.getCellContentMutex.Unlock()
	fake.GetCellContentStub = nil
	if fake.getCellContentReturnsOnCall == nil {
		fake.getCellContentReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getCellContentReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTable) GetSelection() (int, int) {
	fake.getSelectionMutex.Lock()
	ret, specificReturn := fake.getSelectionReturnsOnCall[len(fake.getSelectionArgsForCall)]
	fake.getSelectionArgsForCall = append(fake.getSelectionArgsForCall, struct {
	}{})
	stub := fake.GetSelectionStub
	fakeReturns := fake.getSelectionReturns
	fake.recordInvocation("GetSelection", []interface{}{})
	fake.getSelectionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTable) GetSelectionCallCount() int {
	fake.getSelectionMutex.RLock()
	defer fake.getSelectionMutex.RUnlock()
	return len(fake.getSelectionArgsForCall)
}

func (fake *FakeTable) GetSelectionCalls(stub func() (int, int)) {
	fake.getSelectionMutex.Lock()
	defer fake.getSelectionMutex.Unlock()
	fake.GetSelectionStub = stub
}

func (fake *FakeTable) GetSelectionReturns(result1 int, result2 int) {
	fake.getSelectionMutex.Lock()
	defer fake.getSelectionMutex.Unlock()
	fake.GetSelectionStub = nil
	fake.getSelectionReturns = struct {
		result1 int
		result2 int
	}{result1, result2}
}

func (fake *FakeTable) GetSelectionReturnsOnCall(i int, result1 int, result2 int) {
	fake.getSelectionMutex.Lock()
	defer fake.getSelectionMutex.Unlock()
	fake.GetSelectionStub = nil
	if fake.getSelectionReturnsOnCall == nil {
		fake.getSelectionReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
		})
	}
	fake.getSelectionReturnsOnCall[i] = struct {
		result1 int
		result2 int
	}{result1, result2}
}

func (fake *FakeTable) Primitive() tview.Primitive {
	fake.primitiveMutex.Lock()
	ret, specificReturn := fake.primitiveReturnsOnCall[len(fake.primitiveArgsForCall)]
	fake.primitiveArgsForCall = append(fake.primitiveArgsForCall, struct {
	}{})
	stub := fake.PrimitiveStub
	fakeReturns := fake.primitiveReturns
	fake.recordInvocation("Primitive", []interface{}{})
	fake.primitiveMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTable) PrimitiveCallCount() int {
	fake.primitiveMutex.RLock()
	defer fake.primitiveMutex.RUnlock()
	return len(fake.primitiveArgsForCall)
}

func (fake *FakeTable) PrimitiveCalls(stub func() tview.Primitive) {
	fake.primitiveMutex.Lock()
	defer fake.primitiveMutex.Unlock()
	fake.PrimitiveStub = stub
}

func (fake *FakeTable) PrimitiveReturns(result1 tview.Primitive) {
	fake.primitiveMutex.Lock()
	defer fake.primitiveMutex.Unlock()
	fake.PrimitiveStub = nil
	fake.primitiveReturns = struct {
		result1 tview.Primitive
	}{result1}
}

func (fake *FakeTable) PrimitiveReturnsOnCall(i int, result1 tview.Primitive) {
	fake.primitiveMutex.Lock()
	defer fake.primitiveMutex.Unlock()
	fake.PrimitiveStub = nil
	if fake.primitiveReturnsOnCall == nil {
		fake.primitiveReturnsOnCall = make(map[int]struct {
			result1 tview.Primitive
		})
	}
	fake.primitiveReturnsOnCall[i] = struct {
		result1 tview.Primitive
	}{result1}
}

func (fake *FakeTable) RenderHeader(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.renderHeaderMutex.Lock()
	fake.renderHeaderArgsForCall = append(fake.renderHeaderArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.RenderHeaderStub
	fake.recordInvocation("RenderHeader", []interface{}{arg1Copy})
	fake.renderHeaderMutex.Unlock()
	if stub != nil {
		fake.RenderHeaderStub(arg1)
	}
}

func (fake *FakeTable) RenderHeaderCallCount() int {
	fake.renderHeaderMutex.RLock()
	defer fake.renderHeaderMutex.RUnlock()
	return len(fake.renderHeaderArgsForCall)
}

func (fake *FakeTable) RenderHeaderCalls(stub func([]string)) {
	fake.renderHeaderMutex.Lock()
	defer fake.renderHeaderMutex.Unlock()
	fake.RenderHeaderStub = stub
}

func (fake *FakeTable) RenderHeaderArgsForCall(i int) []string {
	fake.renderHeaderMutex.RLock()
	defer fake.renderHeaderMutex.RUnlock()
	argsForCall := fake.renderHeaderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTable) RenderRow(arg1 []string, arg2 int, arg3 tcell.Color) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.renderRowMutex.Lock()
	fake.renderRowArgsForCall = append(fake.renderRowArgsForCall, struct {
		arg1 []string
		arg2 int
		arg3 tcell.Color
	}{arg1Copy, arg2, arg3})
	stub := fake.RenderRowStub
	fake.recordInvocation("RenderRow", []interface{}{arg1Copy, arg2, arg3})
	fake.renderRowMutex.Unlock()
	if stub != nil {
		fake.RenderRowStub(arg1, arg2, arg3)
	}
}

func (fake *FakeTable) RenderRowCallCount() int {
	fake.renderRowMutex.RLock()
	defer fake.renderRowMutex.RUnlock()
	return len(fake.renderRowArgsForCall)
}

func (fake *FakeTable) RenderRowCalls(stub func([]string, int, tcell.Color)) {
	fake.renderRowMutex.Lock()
	defer fake.renderRowMutex.Unlock()
	fake.RenderRowStub = stub
}

func (fake *FakeTable) RenderRowArgsForCall(i int) ([]string, int, tcell.Color) {
	fake.renderRowMutex.RLock()
	defer fake.renderRowMutex.RUnlock()
	argsForCall := fake.renderRowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTable) ScrollToTop() *tview.Table {
	fake.scrollToTopMutex.Lock()
	ret, specificReturn := fake.scrollToTopReturnsOnCall[len(fake.scrollToTopArgsForCall)]
	fake.scrollToTopArgsForCall = append(fake.scrollToTopArgsForCall, struct {
	}{})
	stub := fake.ScrollToTopStub
	fakeReturns := fake.scrollToTopReturns
	fake.recordInvocation("ScrollToTop", []interface{}{})
	fake.scrollToTopMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTable) ScrollToTopCallCount() int {
	fake.scrollToTopMutex.RLock()
	defer fake.scrollToTopMutex.RUnlock()
	return len(fake.scrollToTopArgsForCall)
}

func (fake *FakeTable) ScrollToTopCalls(stub func() *tview.Table) {
	fake.scrollToTopMutex.Lock()
	defer fake.scrollToTopMutex.Unlock()
	fake.ScrollToTopStub = stub
}

func (fake *FakeTable) ScrollToTopReturns(result1 *tview.Table) {
	fake.scrollToTopMutex.Lock()
	defer fake.scrollToTopMutex.Unlock()
	fake.ScrollToTopStub = nil
	fake.scrollToTopReturns = struct {
		result1 *tview.Table
	}{result1}
}

func (fake *FakeTable) ScrollToTopReturnsOnCall(i int, result1 *tview.Table) {
	fake.scrollToTopMutex.Lock()
	defer fake.scrollToTopMutex.Unlock()
	fake.ScrollToTopStub = nil
	if fake.scrollToTopReturnsOnCall == nil {
		fake.scrollToTopReturnsOnCall = make(map[int]struct {
			result1 *tview.Table
		})
	}
	fake.scrollToTopReturnsOnCall[i] = struct {
		result1 *tview.Table
	}{result1}
}

func (fake *FakeTable) SetInputCapture(arg1 func(event *tcell.EventKey) *tcell.EventKey) {
	fake.setInputCaptureMutex.Lock()
	fake.setInputCaptureArgsForCall = append(fake.setInputCaptureArgsForCall, struct {
		arg1 func(event *tcell.EventKey) *tcell.EventKey
	}{arg1})
	stub := fake.SetInputCaptureStub
	fake.recordInvocation("SetInputCapture", []interface{}{arg1})
	fake.setInputCaptureMutex.Unlock()
	if stub != nil {
		fake.SetInputCaptureStub(arg1)
	}
}

func (fake *FakeTable) SetInputCaptureCallCount() int {
	fake.setInputCaptureMutex.RLock()
	defer fake.setInputCaptureMutex.RUnlock()
	return len(fake.setInputCaptureArgsForCall)
}

func (fake *FakeTable) SetInputCaptureCalls(stub func(func(event *tcell.EventKey) *tcell.EventKey)) {
	fake.setInputCaptureMutex.Lock()
	defer fake.setInputCaptureMutex.Unlock()
	fake.SetInputCaptureStub = stub
}

func (fake *FakeTable) SetInputCaptureArgsForCall(i int) func(event *tcell.EventKey) *tcell.EventKey {
	fake.setInputCaptureMutex.RLock()
	defer fake.setInputCaptureMutex.RUnlock()
	argsForCall := fake.setInputCaptureArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTable) SetSelectedFunc(arg1 func(row int, column int)) {
	fake.setSelectedFuncMutex.Lock()
	fake.setSelectedFuncArgsForCall = append(fake.setSelectedFuncArgsForCall, struct {
		arg1 func(row int, column int)
	}{arg1})
	stub := fake.SetSelectedFuncStub
	fake.recordInvocation("SetSelectedFunc", []interface{}{arg1})
	fake.setSelectedFuncMutex.Unlock()
	if stub != nil {
		fake.SetSelectedFuncStub(arg1)
	}
}

func (fake *FakeTable) SetSelectedFuncCallCount() int {
	fake.setSelectedFuncMutex.RLock()
	defer fake.setSelectedFuncMutex.RUnlock()
	return len(fake.setSelectedFuncArgsForCall)
}

func (fake *FakeTable) SetSelectedFuncCalls(stub func(func(row int, column int))) {
	fake.setSelectedFuncMutex.Lock()
	defer fake.setSelectedFuncMutex.Unlock()
	fake.SetSelectedFuncStub = stub
}

func (fake *FakeTable) SetSelectedFuncArgsForCall(i int) func(row int, column int) {
	fake.setSelectedFuncMutex.RLock()
	defer fake.setSelectedFuncMutex.RUnlock()
	argsForCall := fake.setSelectedFuncArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTable) SetTitle(arg1 string, arg2 ...interface{}) {
	fake.setTitleMutex.Lock()
	fake.setTitleArgsForCall = append(fake.setTitleArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.SetTitleStub
	fake.recordInvocation("SetTitle", []interface{}{arg1, arg2})
	fake.setTitleMutex.Unlock()
	if stub != nil {
		fake.SetTitleStub(arg1, arg2...)
	}
}

func (fake *FakeTable) SetTitleCallCount() int {
	fake.setTitleMutex.RLock()
	defer fake.setTitleMutex.RUnlock()
	return len(fake.setTitleArgsForCall)
}

func (fake *FakeTable) SetTitleCalls(stub func(string, ...interface{})) {
	fake.setTitleMutex.Lock()
	defer fake.setTitleMutex.Unlock()
	fake.SetTitleStub = stub
}

func (fake *FakeTable) SetTitleArgsForCall(i int) (string, []interface{}) {
	fake.setTitleMutex.RLock()
	defer fake.setTitleMutex.RUnlock()
	argsForCall := fake.setTitleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTable) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	fake.getCellContentMutex.RLock()
	defer fake.getCellContentMutex.RUnlock()
	fake.getSelectionMutex.RLock()
	defer fake.getSelectionMutex.RUnlock()
	fake.primitiveMutex.RLock()
	defer fake.primitiveMutex.RUnlock()
	fake.renderHeaderMutex.RLock()
	defer fake.renderHeaderMutex.RUnlock()
	fake.renderRowMutex.RLock()
	defer fake.renderRowMutex.RUnlock()
	fake.scrollToTopMutex.RLock()
	defer fake.scrollToTopMutex.RUnlock()
	fake.setInputCaptureMutex.RLock()
	defer fake.setInputCaptureMutex.RUnlock()
	fake.setSelectedFuncMutex.RLock()
	defer fake.setSelectedFuncMutex.RUnlock()
	fake.setTitleMutex.RLock()
	defer fake.setTitleMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTable) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ component.Table = new(FakeTable)
