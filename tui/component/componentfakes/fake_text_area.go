// Code generated by counterfeiter. DO NOT EDIT.
package componentfakes

import (
	"sync"

	"github.com/dkyanakiev/vaulty/tui/component"
	tcell "github.com/gdamore/tcell/v2"
	"github.com/rivo/tview"
)

type FakeTextArea struct {
	GetTextStub        func() string
	getTextMutex       sync.RWMutex
	getTextArgsForCall []struct {
	}
	getTextReturns struct {
		result1 string
	}
	getTextReturnsOnCall map[int]struct {
		result1 string
	}
	PrimitiveStub        func() tview.Primitive
	primitiveMutex       sync.RWMutex
	primitiveArgsForCall []struct {
	}
	primitiveReturns struct {
		result1 tview.Primitive
	}
	primitiveReturnsOnCall map[int]struct {
		result1 tview.Primitive
	}
	SetBorderStub        func(bool)
	setBorderMutex       sync.RWMutex
	setBorderArgsForCall []struct {
		arg1 bool
	}
	SetBorderColorStub        func(tcell.Color)
	setBorderColorMutex       sync.RWMutex
	setBorderColorArgsForCall []struct {
		arg1 tcell.Color
	}
	SetTextStub        func(string, bool) *tview.TextArea
	setTextMutex       sync.RWMutex
	setTextArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	setTextReturns struct {
		result1 *tview.TextArea
	}
	setTextReturnsOnCall map[int]struct {
		result1 *tview.TextArea
	}
	SetTitleStub        func(string)
	setTitleMutex       sync.RWMutex
	setTitleArgsForCall []struct {
		arg1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTextArea) GetText() string {
	fake.getTextMutex.Lock()
	ret, specificReturn := fake.getTextReturnsOnCall[len(fake.getTextArgsForCall)]
	fake.getTextArgsForCall = append(fake.getTextArgsForCall, struct {
	}{})
	stub := fake.GetTextStub
	fakeReturns := fake.getTextReturns
	fake.recordInvocation("GetText", []interface{}{})
	fake.getTextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTextArea) GetTextCallCount() int {
	fake.getTextMutex.RLock()
	defer fake.getTextMutex.RUnlock()
	return len(fake.getTextArgsForCall)
}

func (fake *FakeTextArea) GetTextCalls(stub func() string) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = stub
}

func (fake *FakeTextArea) GetTextReturns(result1 string) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = nil
	fake.getTextReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTextArea) GetTextReturnsOnCall(i int, result1 string) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = nil
	if fake.getTextReturnsOnCall == nil {
		fake.getTextReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getTextReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTextArea) Primitive() tview.Primitive {
	fake.primitiveMutex.Lock()
	ret, specificReturn := fake.primitiveReturnsOnCall[len(fake.primitiveArgsForCall)]
	fake.primitiveArgsForCall = append(fake.primitiveArgsForCall, struct {
	}{})
	stub := fake.PrimitiveStub
	fakeReturns := fake.primitiveReturns
	fake.recordInvocation("Primitive", []interface{}{})
	fake.primitiveMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTextArea) PrimitiveCallCount() int {
	fake.primitiveMutex.RLock()
	defer fake.primitiveMutex.RUnlock()
	return len(fake.primitiveArgsForCall)
}

func (fake *FakeTextArea) PrimitiveCalls(stub func() tview.Primitive) {
	fake.primitiveMutex.Lock()
	defer fake.primitiveMutex.Unlock()
	fake.PrimitiveStub = stub
}

func (fake *FakeTextArea) PrimitiveReturns(result1 tview.Primitive) {
	fake.primitiveMutex.Lock()
	defer fake.primitiveMutex.Unlock()
	fake.PrimitiveStub = nil
	fake.primitiveReturns = struct {
		result1 tview.Primitive
	}{result1}
}

func (fake *FakeTextArea) PrimitiveReturnsOnCall(i int, result1 tview.Primitive) {
	fake.primitiveMutex.Lock()
	defer fake.primitiveMutex.Unlock()
	fake.PrimitiveStub = nil
	if fake.primitiveReturnsOnCall == nil {
		fake.primitiveReturnsOnCall = make(map[int]struct {
			result1 tview.Primitive
		})
	}
	fake.primitiveReturnsOnCall[i] = struct {
		result1 tview.Primitive
	}{result1}
}

func (fake *FakeTextArea) SetBorder(arg1 bool) {
	fake.setBorderMutex.Lock()
	fake.setBorderArgsForCall = append(fake.setBorderArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.SetBorderStub
	fake.recordInvocation("SetBorder", []interface{}{arg1})
	fake.setBorderMutex.Unlock()
	if stub != nil {
		fake.SetBorderStub(arg1)
	}
}

func (fake *FakeTextArea) SetBorderCallCount() int {
	fake.setBorderMutex.RLock()
	defer fake.setBorderMutex.RUnlock()
	return len(fake.setBorderArgsForCall)
}

func (fake *FakeTextArea) SetBorderCalls(stub func(bool)) {
	fake.setBorderMutex.Lock()
	defer fake.setBorderMutex.Unlock()
	fake.SetBorderStub = stub
}

func (fake *FakeTextArea) SetBorderArgsForCall(i int) bool {
	fake.setBorderMutex.RLock()
	defer fake.setBorderMutex.RUnlock()
	argsForCall := fake.setBorderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTextArea) SetBorderColor(arg1 tcell.Color) {
	fake.setBorderColorMutex.Lock()
	fake.setBorderColorArgsForCall = append(fake.setBorderColorArgsForCall, struct {
		arg1 tcell.Color
	}{arg1})
	stub := fake.SetBorderColorStub
	fake.recordInvocation("SetBorderColor", []interface{}{arg1})
	fake.setBorderColorMutex.Unlock()
	if stub != nil {
		fake.SetBorderColorStub(arg1)
	}
}

func (fake *FakeTextArea) SetBorderColorCallCount() int {
	fake.setBorderColorMutex.RLock()
	defer fake.setBorderColorMutex.RUnlock()
	return len(fake.setBorderColorArgsForCall)
}

func (fake *FakeTextArea) SetBorderColorCalls(stub func(tcell.Color)) {
	fake.setBorderColorMutex.Lock()
	defer fake.setBorderColorMutex.Unlock()
	fake.SetBorderColorStub = stub
}

func (fake *FakeTextArea) SetBorderColorArgsForCall(i int) tcell.Color {
	fake.setBorderColorMutex.RLock()
	defer fake.setBorderColorMutex.RUnlock()
	argsForCall := fake.setBorderColorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTextArea) SetText(arg1 string, arg2 bool) *tview.TextArea {
	fake.setTextMutex.Lock()
	ret, specificReturn := fake.setTextReturnsOnCall[len(fake.setTextArgsForCall)]
	fake.setTextArgsForCall = append(fake.setTextArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	stub := fake.SetTextStub
	fakeReturns := fake.setTextReturns
	fake.recordInvocation("SetText", []interface{}{arg1, arg2})
	fake.setTextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTextArea) SetTextCallCount() int {
	fake.setTextMutex.RLock()
	defer fake.setTextMutex.RUnlock()
	return len(fake.setTextArgsForCall)
}

func (fake *FakeTextArea) SetTextCalls(stub func(string, bool) *tview.TextArea) {
	fake.setTextMutex.Lock()
	defer fake.setTextMutex.Unlock()
	fake.SetTextStub = stub
}

func (fake *FakeTextArea) SetTextArgsForCall(i int) (string, bool) {
	fake.setTextMutex.RLock()
	defer fake.setTextMutex.RUnlock()
	argsForCall := fake.setTextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTextArea) SetTextReturns(result1 *tview.TextArea) {
	fake.setTextMutex.Lock()
	defer fake.setTextMutex.Unlock()
	fake.SetTextStub = nil
	fake.setTextReturns = struct {
		result1 *tview.TextArea
	}{result1}
}

func (fake *FakeTextArea) SetTextReturnsOnCall(i int, result1 *tview.TextArea) {
	fake.setTextMutex.Lock()
	defer fake.setTextMutex.Unlock()
	fake.SetTextStub = nil
	if fake.setTextReturnsOnCall == nil {
		fake.setTextReturnsOnCall = make(map[int]struct {
			result1 *tview.TextArea
		})
	}
	fake.setTextReturnsOnCall[i] = struct {
		result1 *tview.TextArea
	}{result1}
}

func (fake *FakeTextArea) SetTitle(arg1 string) {
	fake.setTitleMutex.Lock()
	fake.setTitleArgsForCall = append(fake.setTitleArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetTitleStub
	fake.recordInvocation("SetTitle", []interface{}{arg1})
	fake.setTitleMutex.Unlock()
	if stub != nil {
		fake.SetTitleStub(arg1)
	}
}

func (fake *FakeTextArea) SetTitleCallCount() int {
	fake.setTitleMutex.RLock()
	defer fake.setTitleMutex.RUnlock()
	return len(fake.setTitleArgsForCall)
}

func (fake *FakeTextArea) SetTitleCalls(stub func(string)) {
	fake.setTitleMutex.Lock()
	defer fake.setTitleMutex.Unlock()
	fake.SetTitleStub = stub
}

func (fake *FakeTextArea) SetTitleArgsForCall(i int) string {
	fake.setTitleMutex.RLock()
	defer fake.setTitleMutex.RUnlock()
	argsForCall := fake.setTitleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTextArea) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getTextMutex.RLock()
	defer fake.getTextMutex.RUnlock()
	fake.primitiveMutex.RLock()
	defer fake.primitiveMutex.RUnlock()
	fake.setBorderMutex.RLock()
	defer fake.setBorderMutex.RUnlock()
	fake.setBorderColorMutex.RLock()
	defer fake.setBorderColorMutex.RUnlock()
	fake.setTextMutex.RLock()
	defer fake.setTextMutex.RUnlock()
	fake.setTitleMutex.RLock()
	defer fake.setTitleMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTextArea) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ component.TextArea = new(FakeTextArea)
