// Code generated by counterfeiter. DO NOT EDIT.
package componentfakes

import (
	"sync"

	"github.com/dkyanakiev/vaulty/tui/component"
	"github.com/rivo/tview"
)

type FakeTextView struct {
	ClearStub        func() *tview.TextView
	clearMutex       sync.RWMutex
	clearArgsForCall []struct {
	}
	clearReturns struct {
		result1 *tview.TextView
	}
	clearReturnsOnCall map[int]struct {
		result1 *tview.TextView
	}
	GetTextStub        func(bool) string
	getTextMutex       sync.RWMutex
	getTextArgsForCall []struct {
		arg1 bool
	}
	getTextReturns struct {
		result1 string
	}
	getTextReturnsOnCall map[int]struct {
		result1 string
	}
	HighlightStub        func(...string) *tview.TextView
	highlightMutex       sync.RWMutex
	highlightArgsForCall []struct {
		arg1 []string
	}
	highlightReturns struct {
		result1 *tview.TextView
	}
	highlightReturnsOnCall map[int]struct {
		result1 *tview.TextView
	}
	ModifyPrimitiveStub        func(func(t *tview.TextView))
	modifyPrimitiveMutex       sync.RWMutex
	modifyPrimitiveArgsForCall []struct {
		arg1 func(t *tview.TextView)
	}
	PrimitiveStub        func() tview.Primitive
	primitiveMutex       sync.RWMutex
	primitiveArgsForCall []struct {
	}
	primitiveReturns struct {
		result1 tview.Primitive
	}
	primitiveReturnsOnCall map[int]struct {
		result1 tview.Primitive
	}
	ScrollToBeginningStub        func() *tview.TextView
	scrollToBeginningMutex       sync.RWMutex
	scrollToBeginningArgsForCall []struct {
	}
	scrollToBeginningReturns struct {
		result1 *tview.TextView
	}
	scrollToBeginningReturnsOnCall map[int]struct {
		result1 *tview.TextView
	}
	ScrollToEndStub        func() *tview.TextView
	scrollToEndMutex       sync.RWMutex
	scrollToEndArgsForCall []struct {
	}
	scrollToEndReturns struct {
		result1 *tview.TextView
	}
	scrollToEndReturnsOnCall map[int]struct {
		result1 *tview.TextView
	}
	SetBorderStub        func(bool)
	setBorderMutex       sync.RWMutex
	setBorderArgsForCall []struct {
		arg1 bool
	}
	SetTextStub        func(string) *tview.TextView
	setTextMutex       sync.RWMutex
	setTextArgsForCall []struct {
		arg1 string
	}
	setTextReturns struct {
		result1 *tview.TextView
	}
	setTextReturnsOnCall map[int]struct {
		result1 *tview.TextView
	}
	SetTextAlignStub        func(int) *tview.TextView
	setTextAlignMutex       sync.RWMutex
	setTextAlignArgsForCall []struct {
		arg1 int
	}
	setTextAlignReturns struct {
		result1 *tview.TextView
	}
	setTextAlignReturnsOnCall map[int]struct {
		result1 *tview.TextView
	}
	SetTitleStub        func(string)
	setTitleMutex       sync.RWMutex
	setTitleArgsForCall []struct {
		arg1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTextView) Clear() *tview.TextView {
	fake.clearMutex.Lock()
	ret, specificReturn := fake.clearReturnsOnCall[len(fake.clearArgsForCall)]
	fake.clearArgsForCall = append(fake.clearArgsForCall, struct {
	}{})
	stub := fake.ClearStub
	fakeReturns := fake.clearReturns
	fake.recordInvocation("Clear", []interface{}{})
	fake.clearMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTextView) ClearCallCount() int {
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	return len(fake.clearArgsForCall)
}

func (fake *FakeTextView) ClearCalls(stub func() *tview.TextView) {
	fake.clearMutex.Lock()
	defer fake.clearMutex.Unlock()
	fake.ClearStub = stub
}

func (fake *FakeTextView) ClearReturns(result1 *tview.TextView) {
	fake.clearMutex.Lock()
	defer fake.clearMutex.Unlock()
	fake.ClearStub = nil
	fake.clearReturns = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) ClearReturnsOnCall(i int, result1 *tview.TextView) {
	fake.clearMutex.Lock()
	defer fake.clearMutex.Unlock()
	fake.ClearStub = nil
	if fake.clearReturnsOnCall == nil {
		fake.clearReturnsOnCall = make(map[int]struct {
			result1 *tview.TextView
		})
	}
	fake.clearReturnsOnCall[i] = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) GetText(arg1 bool) string {
	fake.getTextMutex.Lock()
	ret, specificReturn := fake.getTextReturnsOnCall[len(fake.getTextArgsForCall)]
	fake.getTextArgsForCall = append(fake.getTextArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.GetTextStub
	fakeReturns := fake.getTextReturns
	fake.recordInvocation("GetText", []interface{}{arg1})
	fake.getTextMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTextView) GetTextCallCount() int {
	fake.getTextMutex.RLock()
	defer fake.getTextMutex.RUnlock()
	return len(fake.getTextArgsForCall)
}

func (fake *FakeTextView) GetTextCalls(stub func(bool) string) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = stub
}

func (fake *FakeTextView) GetTextArgsForCall(i int) bool {
	fake.getTextMutex.RLock()
	defer fake.getTextMutex.RUnlock()
	argsForCall := fake.getTextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTextView) GetTextReturns(result1 string) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = nil
	fake.getTextReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTextView) GetTextReturnsOnCall(i int, result1 string) {
	fake.getTextMutex.Lock()
	defer fake.getTextMutex.Unlock()
	fake.GetTextStub = nil
	if fake.getTextReturnsOnCall == nil {
		fake.getTextReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getTextReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTextView) Highlight(arg1 ...string) *tview.TextView {
	fake.highlightMutex.Lock()
	ret, specificReturn := fake.highlightReturnsOnCall[len(fake.highlightArgsForCall)]
	fake.highlightArgsForCall = append(fake.highlightArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.HighlightStub
	fakeReturns := fake.highlightReturns
	fake.recordInvocation("Highlight", []interface{}{arg1})
	fake.highlightMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTextView) HighlightCallCount() int {
	fake.highlightMutex.RLock()
	defer fake.highlightMutex.RUnlock()
	return len(fake.highlightArgsForCall)
}

func (fake *FakeTextView) HighlightCalls(stub func(...string) *tview.TextView) {
	fake.highlightMutex.Lock()
	defer fake.highlightMutex.Unlock()
	fake.HighlightStub = stub
}

func (fake *FakeTextView) HighlightArgsForCall(i int) []string {
	fake.highlightMutex.RLock()
	defer fake.highlightMutex.RUnlock()
	argsForCall := fake.highlightArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTextView) HighlightReturns(result1 *tview.TextView) {
	fake.highlightMutex.Lock()
	defer fake.highlightMutex.Unlock()
	fake.HighlightStub = nil
	fake.highlightReturns = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) HighlightReturnsOnCall(i int, result1 *tview.TextView) {
	fake.highlightMutex.Lock()
	defer fake.highlightMutex.Unlock()
	fake.HighlightStub = nil
	if fake.highlightReturnsOnCall == nil {
		fake.highlightReturnsOnCall = make(map[int]struct {
			result1 *tview.TextView
		})
	}
	fake.highlightReturnsOnCall[i] = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) ModifyPrimitive(arg1 func(t *tview.TextView)) {
	fake.modifyPrimitiveMutex.Lock()
	fake.modifyPrimitiveArgsForCall = append(fake.modifyPrimitiveArgsForCall, struct {
		arg1 func(t *tview.TextView)
	}{arg1})
	stub := fake.ModifyPrimitiveStub
	fake.recordInvocation("ModifyPrimitive", []interface{}{arg1})
	fake.modifyPrimitiveMutex.Unlock()
	if stub != nil {
		fake.ModifyPrimitiveStub(arg1)
	}
}

func (fake *FakeTextView) ModifyPrimitiveCallCount() int {
	fake.modifyPrimitiveMutex.RLock()
	defer fake.modifyPrimitiveMutex.RUnlock()
	return len(fake.modifyPrimitiveArgsForCall)
}

func (fake *FakeTextView) ModifyPrimitiveCalls(stub func(func(t *tview.TextView))) {
	fake.modifyPrimitiveMutex.Lock()
	defer fake.modifyPrimitiveMutex.Unlock()
	fake.ModifyPrimitiveStub = stub
}

func (fake *FakeTextView) ModifyPrimitiveArgsForCall(i int) func(t *tview.TextView) {
	fake.modifyPrimitiveMutex.RLock()
	defer fake.modifyPrimitiveMutex.RUnlock()
	argsForCall := fake.modifyPrimitiveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTextView) Primitive() tview.Primitive {
	fake.primitiveMutex.Lock()
	ret, specificReturn := fake.primitiveReturnsOnCall[len(fake.primitiveArgsForCall)]
	fake.primitiveArgsForCall = append(fake.primitiveArgsForCall, struct {
	}{})
	stub := fake.PrimitiveStub
	fakeReturns := fake.primitiveReturns
	fake.recordInvocation("Primitive", []interface{}{})
	fake.primitiveMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTextView) PrimitiveCallCount() int {
	fake.primitiveMutex.RLock()
	defer fake.primitiveMutex.RUnlock()
	return len(fake.primitiveArgsForCall)
}

func (fake *FakeTextView) PrimitiveCalls(stub func() tview.Primitive) {
	fake.primitiveMutex.Lock()
	defer fake.primitiveMutex.Unlock()
	fake.PrimitiveStub = stub
}

func (fake *FakeTextView) PrimitiveReturns(result1 tview.Primitive) {
	fake.primitiveMutex.Lock()
	defer fake.primitiveMutex.Unlock()
	fake.PrimitiveStub = nil
	fake.primitiveReturns = struct {
		result1 tview.Primitive
	}{result1}
}

func (fake *FakeTextView) PrimitiveReturnsOnCall(i int, result1 tview.Primitive) {
	fake.primitiveMutex.Lock()
	defer fake.primitiveMutex.Unlock()
	fake.PrimitiveStub = nil
	if fake.primitiveReturnsOnCall == nil {
		fake.primitiveReturnsOnCall = make(map[int]struct {
			result1 tview.Primitive
		})
	}
	fake.primitiveReturnsOnCall[i] = struct {
		result1 tview.Primitive
	}{result1}
}

func (fake *FakeTextView) ScrollToBeginning() *tview.TextView {
	fake.scrollToBeginningMutex.Lock()
	ret, specificReturn := fake.scrollToBeginningReturnsOnCall[len(fake.scrollToBeginningArgsForCall)]
	fake.scrollToBeginningArgsForCall = append(fake.scrollToBeginningArgsForCall, struct {
	}{})
	stub := fake.ScrollToBeginningStub
	fakeReturns := fake.scrollToBeginningReturns
	fake.recordInvocation("ScrollToBeginning", []interface{}{})
	fake.scrollToBeginningMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTextView) ScrollToBeginningCallCount() int {
	fake.scrollToBeginningMutex.RLock()
	defer fake.scrollToBeginningMutex.RUnlock()
	return len(fake.scrollToBeginningArgsForCall)
}

func (fake *FakeTextView) ScrollToBeginningCalls(stub func() *tview.TextView) {
	fake.scrollToBeginningMutex.Lock()
	defer fake.scrollToBeginningMutex.Unlock()
	fake.ScrollToBeginningStub = stub
}

func (fake *FakeTextView) ScrollToBeginningReturns(result1 *tview.TextView) {
	fake.scrollToBeginningMutex.Lock()
	defer fake.scrollToBeginningMutex.Unlock()
	fake.ScrollToBeginningStub = nil
	fake.scrollToBeginningReturns = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) ScrollToBeginningReturnsOnCall(i int, result1 *tview.TextView) {
	fake.scrollToBeginningMutex.Lock()
	defer fake.scrollToBeginningMutex.Unlock()
	fake.ScrollToBeginningStub = nil
	if fake.scrollToBeginningReturnsOnCall == nil {
		fake.scrollToBeginningReturnsOnCall = make(map[int]struct {
			result1 *tview.TextView
		})
	}
	fake.scrollToBeginningReturnsOnCall[i] = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) ScrollToEnd() *tview.TextView {
	fake.scrollToEndMutex.Lock()
	ret, specificReturn := fake.scrollToEndReturnsOnCall[len(fake.scrollToEndArgsForCall)]
	fake.scrollToEndArgsForCall = append(fake.scrollToEndArgsForCall, struct {
	}{})
	stub := fake.ScrollToEndStub
	fakeReturns := fake.scrollToEndReturns
	fake.recordInvocation("ScrollToEnd", []interface{}{})
	fake.scrollToEndMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTextView) ScrollToEndCallCount() int {
	fake.scrollToEndMutex.RLock()
	defer fake.scrollToEndMutex.RUnlock()
	return len(fake.scrollToEndArgsForCall)
}

func (fake *FakeTextView) ScrollToEndCalls(stub func() *tview.TextView) {
	fake.scrollToEndMutex.Lock()
	defer fake.scrollToEndMutex.Unlock()
	fake.ScrollToEndStub = stub
}

func (fake *FakeTextView) ScrollToEndReturns(result1 *tview.TextView) {
	fake.scrollToEndMutex.Lock()
	defer fake.scrollToEndMutex.Unlock()
	fake.ScrollToEndStub = nil
	fake.scrollToEndReturns = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) ScrollToEndReturnsOnCall(i int, result1 *tview.TextView) {
	fake.scrollToEndMutex.Lock()
	defer fake.scrollToEndMutex.Unlock()
	fake.ScrollToEndStub = nil
	if fake.scrollToEndReturnsOnCall == nil {
		fake.scrollToEndReturnsOnCall = make(map[int]struct {
			result1 *tview.TextView
		})
	}
	fake.scrollToEndReturnsOnCall[i] = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) SetBorder(arg1 bool) {
	fake.setBorderMutex.Lock()
	fake.setBorderArgsForCall = append(fake.setBorderArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.SetBorderStub
	fake.recordInvocation("SetBorder", []interface{}{arg1})
	fake.setBorderMutex.Unlock()
	if stub != nil {
		fake.SetBorderStub(arg1)
	}
}

func (fake *FakeTextView) SetBorderCallCount() int {
	fake.setBorderMutex.RLock()
	defer fake.setBorderMutex.RUnlock()
	return len(fake.setBorderArgsForCall)
}

func (fake *FakeTextView) SetBorderCalls(stub func(bool)) {
	fake.setBorderMutex.Lock()
	defer fake.setBorderMutex.Unlock()
	fake.SetBorderStub = stub
}

func (fake *FakeTextView) SetBorderArgsForCall(i int) bool {
	fake.setBorderMutex.RLock()
	defer fake.setBorderMutex.RUnlock()
	argsForCall := fake.setBorderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTextView) SetText(arg1 string) *tview.TextView {
	fake.setTextMutex.Lock()
	ret, specificReturn := fake.setTextReturnsOnCall[len(fake.setTextArgsForCall)]
	fake.setTextArgsForCall = append(fake.setTextArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetTextStub
	fakeReturns := fake.setTextReturns
	fake.recordInvocation("SetText", []interface{}{arg1})
	fake.setTextMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTextView) SetTextCallCount() int {
	fake.setTextMutex.RLock()
	defer fake.setTextMutex.RUnlock()
	return len(fake.setTextArgsForCall)
}

func (fake *FakeTextView) SetTextCalls(stub func(string) *tview.TextView) {
	fake.setTextMutex.Lock()
	defer fake.setTextMutex.Unlock()
	fake.SetTextStub = stub
}

func (fake *FakeTextView) SetTextArgsForCall(i int) string {
	fake.setTextMutex.RLock()
	defer fake.setTextMutex.RUnlock()
	argsForCall := fake.setTextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTextView) SetTextReturns(result1 *tview.TextView) {
	fake.setTextMutex.Lock()
	defer fake.setTextMutex.Unlock()
	fake.SetTextStub = nil
	fake.setTextReturns = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) SetTextReturnsOnCall(i int, result1 *tview.TextView) {
	fake.setTextMutex.Lock()
	defer fake.setTextMutex.Unlock()
	fake.SetTextStub = nil
	if fake.setTextReturnsOnCall == nil {
		fake.setTextReturnsOnCall = make(map[int]struct {
			result1 *tview.TextView
		})
	}
	fake.setTextReturnsOnCall[i] = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) SetTextAlign(arg1 int) *tview.TextView {
	fake.setTextAlignMutex.Lock()
	ret, specificReturn := fake.setTextAlignReturnsOnCall[len(fake.setTextAlignArgsForCall)]
	fake.setTextAlignArgsForCall = append(fake.setTextAlignArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetTextAlignStub
	fakeReturns := fake.setTextAlignReturns
	fake.recordInvocation("SetTextAlign", []interface{}{arg1})
	fake.setTextAlignMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTextView) SetTextAlignCallCount() int {
	fake.setTextAlignMutex.RLock()
	defer fake.setTextAlignMutex.RUnlock()
	return len(fake.setTextAlignArgsForCall)
}

func (fake *FakeTextView) SetTextAlignCalls(stub func(int) *tview.TextView) {
	fake.setTextAlignMutex.Lock()
	defer fake.setTextAlignMutex.Unlock()
	fake.SetTextAlignStub = stub
}

func (fake *FakeTextView) SetTextAlignArgsForCall(i int) int {
	fake.setTextAlignMutex.RLock()
	defer fake.setTextAlignMutex.RUnlock()
	argsForCall := fake.setTextAlignArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTextView) SetTextAlignReturns(result1 *tview.TextView) {
	fake.setTextAlignMutex.Lock()
	defer fake.setTextAlignMutex.Unlock()
	fake.SetTextAlignStub = nil
	fake.setTextAlignReturns = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) SetTextAlignReturnsOnCall(i int, result1 *tview.TextView) {
	fake.setTextAlignMutex.Lock()
	defer fake.setTextAlignMutex.Unlock()
	fake.SetTextAlignStub = nil
	if fake.setTextAlignReturnsOnCall == nil {
		fake.setTextAlignReturnsOnCall = make(map[int]struct {
			result1 *tview.TextView
		})
	}
	fake.setTextAlignReturnsOnCall[i] = struct {
		result1 *tview.TextView
	}{result1}
}

func (fake *FakeTextView) SetTitle(arg1 string) {
	fake.setTitleMutex.Lock()
	fake.setTitleArgsForCall = append(fake.setTitleArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetTitleStub
	fake.recordInvocation("SetTitle", []interface{}{arg1})
	fake.setTitleMutex.Unlock()
	if stub != nil {
		fake.SetTitleStub(arg1)
	}
}

func (fake *FakeTextView) SetTitleCallCount() int {
	fake.setTitleMutex.RLock()
	defer fake.setTitleMutex.RUnlock()
	return len(fake.setTitleArgsForCall)
}

func (fake *FakeTextView) SetTitleCalls(stub func(string)) {
	fake.setTitleMutex.Lock()
	defer fake.setTitleMutex.Unlock()
	fake.SetTitleStub = stub
}

func (fake *FakeTextView) SetTitleArgsForCall(i int) string {
	fake.setTitleMutex.RLock()
	defer fake.setTitleMutex.RUnlock()
	argsForCall := fake.setTitleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTextView) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	fake.getTextMutex.RLock()
	defer fake.getTextMutex.RUnlock()
	fake.highlightMutex.RLock()
	defer fake.highlightMutex.RUnlock()
	fake.modifyPrimitiveMutex.RLock()
	defer fake.modifyPrimitiveMutex.RUnlock()
	fake.primitiveMutex.RLock()
	defer fake.primitiveMutex.RUnlock()
	fake.scrollToBeginningMutex.RLock()
	defer fake.scrollToBeginningMutex.RUnlock()
	fake.scrollToEndMutex.RLock()
	defer fake.scrollToEndMutex.RUnlock()
	fake.setBorderMutex.RLock()
	defer fake.setBorderMutex.RUnlock()
	fake.setTextMutex.RLock()
	defer fake.setTextMutex.RUnlock()
	fake.setTextAlignMutex.RLock()
	defer fake.setTextAlignMutex.RUnlock()
	fake.setTitleMutex.RLock()
	defer fake.setTitleMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTextView) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ component.TextView = new(FakeTextView)
